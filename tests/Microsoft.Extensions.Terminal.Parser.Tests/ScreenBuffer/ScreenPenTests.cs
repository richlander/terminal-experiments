// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

using System.Text;
using Xunit;

namespace Microsoft.Extensions.Terminal.Parser.Tests;

/// <summary>
/// ScreenBuffer pen/attribute tests for screen cells.
/// </summary>
/// <remarks>
/// Ported from libvterm: t/64screen_pen.test
/// Tests that SGR attributes are correctly applied to screen cells
/// and that special sequences like EL respect pen colors.
/// </remarks>
public class ScreenPenTests
{
    private ScreenBuffer CreateBuffer(int width = 80, int height = 25)
        => new ScreenBuffer(width, height);

    private void Parse(ScreenBuffer buffer, string input)
    {
        var parser = new VtParser(buffer);
        parser.Parse(Encoding.UTF8.GetBytes(input));
    }

    #region Plain Text - libvterm "Plain"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Plain"
    /// Plain text has no attributes, default fg/bg.
    /// </summary>
    [Fact]
    public void Plain_NoAttributes()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "A");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('A', cell.Character);
        Assert.Equal(CellAttributes.None, cell.Attributes);
        Assert.Equal(TerminalCell.DefaultForeground, cell.Foreground);
        Assert.Equal(TerminalCell.DefaultBackground, cell.Background);
    }

    #endregion

    #region Bold - libvterm "Bold"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Bold"
    /// SGR 1 enables bold attribute on cell.
    /// </summary>
    [Fact]
    public void Bold_CellHasBoldAttribute()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[1mB");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('B', cell.Character);
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Bold));
    }

    #endregion

    #region Italic - libvterm "Italic"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Italic"
    /// SGR 3 enables italic attribute on cell.
    /// </summary>
    [Fact]
    public void Italic_CellHasItalicAttribute()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[1m\u001b[3mC");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('C', cell.Character);
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Bold));
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Italic));
    }

    [Fact]
    public void Italic_Alone()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[3mI");
        var cell = buffer.GetCell(0, 0);
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Italic));
        Assert.False(cell.Attributes.HasFlag(CellAttributes.Bold));
    }

    #endregion

    #region Underline - libvterm "Underline"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Underline"
    /// SGR 4 enables underline attribute.
    /// </summary>
    [Fact]
    public void Underline_CellHasUnderlineAttribute()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[1m\u001b[3m\u001b[4mD");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('D', cell.Character);
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Bold));
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Italic));
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Underline));
    }

    #endregion

    #region Reset - libvterm "Reset"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Reset"
    /// SGR 0 resets all attributes.
    /// </summary>
    [Fact]
    public void Reset_ClearsAllAttributes()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[1;3;4mX\u001b[mE");
        var cellX = buffer.GetCell(0, 0);
        Assert.True(cellX.Attributes.HasFlag(CellAttributes.Bold));
        var cellE = buffer.GetCell(1, 0);
        Assert.Equal('E', cellE.Character);
        Assert.Equal(CellAttributes.None, cellE.Attributes);
        Assert.Equal(TerminalCell.DefaultForeground, cellE.Foreground);
        Assert.Equal(TerminalCell.DefaultBackground, cellE.Background);
    }

    #endregion

    #region Font - libvterm "Font"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Font"
    /// SGR 11 selects alternate font 1.
    /// </summary>
    [Fact]
    public void Font_AlternateFont()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[11mF\u001b[m");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('F', cell.Character);
    }

    #endregion

    #region Foreground Color - libvterm "Foreground"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Foreground"
    /// SGR 31 sets red foreground.
    /// </summary>
    [Fact]
    public void Foreground_RedColor()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[31mG\u001b[m");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('G', cell.Character);
        Assert.Equal(1u, cell.Foreground);
    }

    [Theory]
    [InlineData(30, 0)]
    [InlineData(31, 1)]
    [InlineData(32, 2)]
    [InlineData(33, 3)]
    [InlineData(34, 4)]
    [InlineData(35, 5)]
    [InlineData(36, 6)]
    [InlineData(37, 7)]
    public void Foreground_StandardColors(int sgr, uint expectedIndex)
    {
        var buffer = CreateBuffer();
        Parse(buffer, $"\u001b[{sgr}mX");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal(expectedIndex, cell.Foreground);
    }

    #endregion

    #region Background Color - libvterm "Background"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Background"
    /// SGR 42 sets green background.
    /// </summary>
    [Fact]
    public void Background_GreenColor()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[42mH\u001b[m");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('H', cell.Character);
        Assert.Equal(2u, cell.Background);
    }

    [Theory]
    [InlineData(40, 0)]
    [InlineData(41, 1)]
    [InlineData(42, 2)]
    [InlineData(43, 3)]
    [InlineData(44, 4)]
    [InlineData(45, 5)]
    [InlineData(46, 6)]
    [InlineData(47, 7)]
    public void Background_StandardColors(int sgr, uint expectedIndex)
    {
        var buffer = CreateBuffer();
        Parse(buffer, $"\u001b[{sgr}mX");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal(expectedIndex, cell.Background);
    }

    #endregion

    #region Superscript/Subscript - libvterm "Super/subscript"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Super/subscript"
    /// SGR 73 = superscript, SGR 74 = subscript.
    /// </summary>
    [Fact]
    public void SuperSubscript_AttributesApplied()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "x\u001b[74m0\u001b[73m2\u001b[m");
        var cellX = buffer.GetCell(0, 0);
        Assert.Equal('x', cellX.Character);
        Assert.Equal(CellAttributes.None, cellX.Attributes);
        var cell0 = buffer.GetCell(1, 0);
        Assert.Equal('0', cell0.Character);
        var cell2 = buffer.GetCell(2, 0);
        Assert.Equal('2', cell2.Character);
    }

    #endregion

    #region EL Sets Colors - libvterm "EL sets only colours to end of line"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "EL sets only colours to end of line, not other attrs"
    /// </summary>
    [Fact]
    public void El_SetsColorsToEndOfLine()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[H\u001b[7;33;44m\u001b[K");
        var cell0 = buffer.GetCell(0, 0);
        Assert.Equal(3u, cell0.Foreground);
        Assert.Equal(4u, cell0.Background);
        var cell79 = buffer.GetCell(79, 0);
        Assert.Equal(3u, cell79.Foreground);
        Assert.Equal(4u, cell79.Background);
    }

    [Fact]
    public void El_ThenWrite_AppliesFullAttributes()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[H\u001b[7;33;44m\u001b[K");
        Parse(buffer, "R");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal('R', cell.Character);
        Assert.True(cell.Attributes.HasFlag(CellAttributes.Inverse));
        Assert.Equal(3u, cell.Foreground);
        Assert.Equal(4u, cell.Background);
    }

    #endregion

    #region DECSCNM - Screen Reverse Mode

    /// <summary>
    /// Ported from: libvterm 64screen_pen "DECSCNM xors reverse for entire screen"
    /// </summary>
    [Fact]
    public void Decscnm_XorsReverseForScreen()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[H\u001b[7;33;44m\u001b[K");
        Parse(buffer, "R\u001b[?5h");
        var cell0 = buffer.GetCell(0, 0);
        Assert.Equal('R', cell0.Character);
    }

    /// <summary>
    /// Ported from: libvterm 64screen_pen "DECSCNM"
    /// </summary>
    [Fact]
    public void Decscnm_CanBeDisabled()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[H\u001b[7;33;44m\u001b[K");
        Parse(buffer, "R\u001b[?5h");
        Parse(buffer, "\u001b[?5l");
        var cell0 = buffer.GetCell(0, 0);
        Assert.Equal('R', cell0.Character);
        Assert.True(cell0.Attributes.HasFlag(CellAttributes.Inverse));
    }

    #endregion

    #region Set Default Colors - libvterm "Set default colours"

    /// <summary>
    /// Ported from: libvterm 64screen_pen "Set default colours"
    /// </summary>
    [Fact]
    public void DefaultColors_AffectDefaultCells()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "ABC");
        var cellA = buffer.GetCell(0, 0);
        Assert.Equal(TerminalCell.DefaultForeground, cellA.Foreground);
        Assert.Equal(TerminalCell.DefaultBackground, cellA.Background);
        Parse(buffer, "\u001b[31mDEF\u001b[m");
        var cellD = buffer.GetCell(3, 0);
        Assert.Equal(1u, cellD.Foreground);
        Assert.Equal(TerminalCell.DefaultBackground, cellD.Background);
    }

    [Fact]
    public void ExplicitColors_NotAffectedByDefaultChange()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[31mRED\u001b[m");
        Parse(buffer, "DEF");
        var cellR = buffer.GetCell(0, 0);
        Assert.Equal(1u, cellR.Foreground);
        var cellD = buffer.GetCell(3, 0);
        Assert.Equal(TerminalCell.DefaultForeground, cellD.Foreground);
    }

    #endregion

    #region Multiple Cells with Same Attributes

    [Fact]
    public void MultipleCells_SameAttributes()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[1;31;44mHELLO");
        for (int i = 0; i < 5; i++)
        {
            var cell = buffer.GetCell(i, 0);
            Assert.True(cell.Attributes.HasFlag(CellAttributes.Bold));
            Assert.Equal(1u, cell.Foreground);
            Assert.Equal(4u, cell.Background);
        }
    }

    [Fact]
    public void AttributeChanges_ApplyToSubsequent()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "A\u001b[1mB\u001b[3mC\u001b[4mD\u001b[mE");
        var cellA = buffer.GetCell(0, 0);
        Assert.Equal(CellAttributes.None, cellA.Attributes);
        var cellB = buffer.GetCell(1, 0);
        Assert.True(cellB.Attributes.HasFlag(CellAttributes.Bold));
        Assert.False(cellB.Attributes.HasFlag(CellAttributes.Italic));
        var cellC = buffer.GetCell(2, 0);
        Assert.True(cellC.Attributes.HasFlag(CellAttributes.Bold));
        Assert.True(cellC.Attributes.HasFlag(CellAttributes.Italic));
        var cellD = buffer.GetCell(3, 0);
        Assert.True(cellD.Attributes.HasFlag(CellAttributes.Bold));
        Assert.True(cellD.Attributes.HasFlag(CellAttributes.Italic));
        Assert.True(cellD.Attributes.HasFlag(CellAttributes.Underline));
        var cellE = buffer.GetCell(4, 0);
        Assert.Equal(CellAttributes.None, cellE.Attributes);
    }

    #endregion

    #region Extended Colors (256 and RGB)

    [Fact]
    public void ExtendedColor_256Foreground()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[38;5;208mX");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal(208u, cell.Foreground);
    }

    [Fact]
    public void ExtendedColor_256Background()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[48;5;123mX");
        var cell = buffer.GetCell(0, 0);
        Assert.Equal(123u, cell.Background);
    }

    [Fact]
    public void TrueColor_RgbForeground()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[38;2;255;128;64mX");
        var cell = buffer.GetCell(0, 0);
        Assert.True(cell.Foreground > 0xFFFFFF);
    }

    [Fact]
    public void TrueColor_RgbBackground()
    {
        var buffer = CreateBuffer();
        Parse(buffer, "\u001b[48;2;10;20;30mX");
        var cell = buffer.GetCell(0, 0);
        Assert.True(cell.Background > 0xFFFFFF);
    }

    #endregion
}
